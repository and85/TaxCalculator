using System;

namespace AndriiCo.TaxCalculatorLib.Entities
{
    /// <summary>
    /// Implementation of Money design pattern: https://martinfowler.com/eaaCatalog/money.html
    /// </summary>
    public sealed class Money
    {
        /// <summary>
        /// Accuracy to which we round fractional numbers
        /// </summary>
        private const int Accuracy = 2;

        /// <summary>
        /// Creates an instance of <see cref="Money"/>
        /// </summary>
        /// <param name="amount">Amount of money</param>
        /// <param name="currency">Currency</param>
        public Money(decimal amount, Currency currency)
        {
            if (amount < 0) throw new ArgumentOutOfRangeException(nameof(amount), "Can't operate with negative numbers!");
            if (currency == null) throw new ArgumentNullException(nameof(currency));

            Amount = Math.Round(amount, Accuracy);
            Currency = currency;
        }

        /// <summary>
        /// Amount of money
        /// </summary>
        public decimal Amount { get; }

        /// <summary>
        /// Currency
        /// </summary>
        public Currency Currency { get; }

        public static Money operator +(Money left, Money right)
        {
            if (!Equals(left.Currency, right.Currency))
                throw new ArgumentException("Can't operate with two different currencies!");

            return new Money(left.Amount + right.Amount, left.Currency);
        }

        public static Money operator -(Money left, Money right)
        {
            if (!Equals(left.Currency, right.Currency))
                throw new ArgumentException("Can't operate with two different currencies!");

            return new Money(left.Amount - right.Amount, left.Currency);
        }

        public static bool operator >=(Money left, Money right)
        {
            if (!Equals(left.Currency, right.Currency))
                throw new ArgumentException("Can't operate with two different currencies!");

            return left.Amount >= right.Amount;
        }

        public static bool operator <=(Money left, Money right)
        {
            if (!Equals(left.Currency, right.Currency))
                throw new ArgumentException("Can't operate with two different currencies!");

            return left.Amount <= right.Amount;
        }

        /// <summary>
        /// Money object after multiplication by a number
        /// </summary>
        /// <param name="number">Number by which money is multiplied</param>
        /// <returns>Returns money object after multiplication by a number</returns>
        public Money MultipyByNumber(decimal number)
        {
            return new Money(Amount * number, Currency);
        }
        
        public override string ToString()
        {
            return $"{Currency.Symbol}{Amount}";
        }

        #region Equals override generated by Resharper
        private bool Equals(Money other)
        {
            return Amount == other.Amount && Equals(Currency, other.Currency);
        }

        public override bool Equals(object obj)
        {
            if (ReferenceEquals(null, obj)) return false;
            if (ReferenceEquals(this, obj)) return true;
            return obj is Money && Equals((Money)obj);
        }

        public override int GetHashCode()
        {
            unchecked
            {
                return (Amount.GetHashCode() * 397) ^ (Currency != null ? Currency.GetHashCode() : 0);
            }
        }
        #endregion
    }
}
